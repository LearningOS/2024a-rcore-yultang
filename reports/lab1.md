# lab1

## 实现功能

- 为`TaskControlBlock`增加完成`sys_task_info`系统调用所需属性;

- 实现相关函数`get_syscall_times`, `get_task_start_time`, `update_syscall_times`;

- 增加在`task`创建或调度时更改状态代码.

## 简答作业

1. 在`ch3`完成的分支下执行：
```bash
make run CHAPTER=2
```
出错行为及说明:
```bash
[kernel] PageFault in application, bad addr = 0x0, bad instruction = 0x804003a4, kernel killed it.
尝试将值写入地址`0x0`;

[kernel] IllegalInstruction in application, kernel killed it.
在用户态执行特权指令`sret`;

[kernel] IllegalInstruction in application, kernel killed it.
在用户态访问控制寄存器`sstatus`;
```

2. 深入理解`trap.S`:
	- `a0`指向当前内核栈上保存的`TrapContext`的地址; 
	`__restore`两种情景: 处理用户模式的异常或者陷阱, 上下文切换.
	
	- `sstatus`确保`CPU`的状态和中断行为符合预期, 避免在用户模式下错误地处理特权级操作或中断;
	`sepc`确保程序能够从正确的位置恢复执行, 防止逻辑错误或崩溃;
	`sscratch`确保用户栈指针正确指向用户栈, 以支持函数调用和局部变量的正常使用.
	
	- 跳过`x2`和`x4`是出于以下考虑:
	`x2`栈指针`sp`: 在陷阱处理过程中`sp`的值已经被修改, 且恢复时的栈指针通过其他机制已处理, 因此不需要再次保存和恢复;
	`x4`线程指针`tp`: 该寄存器在当前上下文中不必要, 减少了不必要的上下文切换开销, 提高了代码效率.
	
	- `sp`指向`sscratch`中存储的值, 即用户栈的地址, `sscratch`被更新为之前`sp`的值, 保存内核栈的顶部地址.

	- `sret`指令, 该指令用于从特权模式返回到用户模式.

	- `sp`: 现在指向用户态栈, 准备执行用户态程序;
	`sscratch`: 保存了之前的内核栈指针, 以便在用户态程序执行结束后可以恢复到内核上下文.
	
	- 常见为`ecall`指令.

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 NULL 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

2. 此外，我也参考了 NULL，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。